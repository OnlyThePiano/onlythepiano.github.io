<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Cocloa is looking at the Piano</title>
    <link>https://onlythepiano.github.io/post/</link>
    <description>Recent content in Posts on Cocloa is looking at the Piano</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 11 Jul 2020 22:00:31 +0800</lastBuildDate>
    
	<atom:link href="https://onlythepiano.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>反射</title>
      <link>https://onlythepiano.github.io/%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 11 Jul 2020 22:00:31 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%8F%8D%E5%B0%84/</guid>
      <description>什么是反射 ？ 反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</description>
    </item>
    
    <item>
      <title>Java基础类库-Class类</title>
      <link>https://onlythepiano.github.io/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93-class%E7%B1%BB/</link>
      <pubDate>Sat, 11 Jul 2020 21:47:29 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93-class%E7%B1%BB/</guid>
      <description>Class 类 Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识，即所谓的RTTI。 这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象</description>
    </item>
    
    <item>
      <title>序列化</title>
      <link>https://onlythepiano.github.io/%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Fri, 10 Jul 2020 13:30:32 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description>原文链接：https://blog.csdn.net/so_geili/article/details/99836043 一、为什么需要序列化 ? java进程运行时会把相关的类生成一堆实例，并放入堆栈空间中，如果进程执行结束，那么内存中的实例对象就会被 gc 回收。如果想在新的程序中使用之前那个对象，应该怎么</description>
    </item>
    
    <item>
      <title>Java集合-Set、List、Map</title>
      <link>https://onlythepiano.github.io/java%E9%9B%86%E5%90%88-setlistmap/</link>
      <pubDate>Thu, 09 Jul 2020 21:53:41 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E9%9B%86%E5%90%88-setlistmap/</guid>
      <description>Java集合-Set、List、Map - List、Set、Map 的区别： List(对付顺序的好帮手)： 存储的元素是有序的、可重复的。 Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。 Map(用 Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上 (x,y)，Key 是无序的、</description>
    </item>
    
    <item>
      <title>Java集合</title>
      <link>https://onlythepiano.github.io/java%E9%9B%86%E5%90%88/</link>
      <pubDate>Thu, 09 Jul 2020 20:42:38 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E9%9B%86%E5%90%88/</guid>
      <description>Java 集合 为了保存数量不确定的数据，以及保存具有映射关系的数据(也被称为关联数组)，Java 提供了集合类。 集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所有的集合类都位于 java.util 包下。 集合类和数组不一样，数组元素既可以是基本类型的值，也可以是对象(实际上保存的是对象的引用变量)；而集合里只能保存</description>
    </item>
    
    <item>
      <title>Java基础类库-String类</title>
      <link>https://onlythepiano.github.io/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93-string%E7%B1%BB/</link>
      <pubDate>Thu, 09 Jul 2020 15:08:01 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93-string%E7%B1%BB/</guid>
      <description>String、StringBuffer 和 StringBuilder 类 字符串类 字符串就是一连串的字符序列，Java 提供了String 和StringBuffer 两个类来封装字符串，并提供了一系列方法来操作字符串对象。 String 类： String 类是不可变类，即一旦一个 String 对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。 StringBuffer</description>
    </item>
    
    <item>
      <title>Java子类父类转换</title>
      <link>https://onlythepiano.github.io/java%E5%AD%90%E7%B1%BB%E7%88%B6%E7%B1%BB%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Thu, 09 Jul 2020 11:29:49 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E5%AD%90%E7%B1%BB%E7%88%B6%E7%B1%BB%E8%BD%AC%E6%8D%A2/</guid>
      <description>java 子类父类转换 子类转父类 因为子类其实是一种特殊的父类， 因此 Java 允许把一个子类对象直接赋给一个父类引用变量， 无须任何类型转换，或者被称为向上转型(upcasting)， 向上转型由系统自动完成。这也是Java中的多态的实现机制。 java 中子类强转父类，实际上依然是子类； 该引用只能调用父类中定义的方法和变量； 如果</description>
    </item>
    
    <item>
      <title>Java基础类库-Object类</title>
      <link>https://onlythepiano.github.io/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93-object%E7%B1%BB/</link>
      <pubDate>Wed, 08 Jul 2020 15:44:26 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93-object%E7%B1%BB/</guid>
      <description>Java 基础类库-Object类 Object 类是 java 默认的提供的一个类，Object 类是所有类的父类，也就是说任何一个类的定义的时候如果没有明确的继承一个父类的话，那么它就是 Object 的子类。 - 常用方法： Class &amp;lt;?&amp;gt; getClass() 方法 返回该对象的运行时类；final 方法，返回 Class 类型的对象，反射来获取对象。 String toString() 方法 一般子类都有覆盖，目的在于获取对</description>
    </item>
    
    <item>
      <title>时间复杂度</title>
      <link>https://onlythepiano.github.io/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Wed, 08 Jul 2020 10:16:48 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>- 衡量代码的好坏，包括两个非常重要的指标： 运行时间； 占用空间； 原文链接：https://blog.csdn.net/qq_41523096/article/details/82142747 执行次数 场景1： 给小灰一条长10寸的面包，小灰每3天吃掉1寸，那么吃掉整个面包需要几天？ 答案自然是 3 X 10 = 30天</description>
    </item>
    
    <item>
      <title>泛型</title>
      <link>https://onlythepiano.github.io/%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Tue, 07 Jul 2020 22:51:03 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E6%B3%9B%E5%9E%8B/</guid>
      <description>泛型 所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参将在声明变量、创建对 象、调用方法时动态地指定( 即传入实际的类型参数，也可称为类型实参)。Java 5改写了集合框架中 的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类 型实参，这就是在前面程序中</description>
    </item>
    
    <item>
      <title>7号杯</title>
      <link>https://onlythepiano.github.io/7%E5%8F%B7%E6%9D%AF/</link>
      <pubDate>Sun, 05 Jul 2020 22:13:55 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/7%E5%8F%B7%E6%9D%AF/</guid>
      <description>！ 害！</description>
    </item>
    
    <item>
      <title>桥接模式</title>
      <link>https://onlythepiano.github.io/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 04 Jul 2020 20:36:08 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>合成、聚合复用原则 “在面向对象设计中，有一个很重要的设计原则，那就是合成/聚合复用原则。即优先使用对象合成/聚合，而不是类继承。” - 继承带来的坏处： 很多情况用继承会带来麻烦，比如：对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至</description>
    </item>
    
    <item>
      <title>Java并发-进程线程2</title>
      <link>https://onlythepiano.github.io/java%E5%B9%B6%E5%8F%91-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B2/</link>
      <pubDate>Fri, 03 Jul 2020 09:56:08 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E5%B9%B6%E5%8F%91-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B2/</guid>
      <description>进程线程2 共享和私有资源 - 线程共享： Java 堆 方法区 - 线程私有： 程序计数器 虚拟机栈 本地方法栈 - 程序计数器为什么私有 ？ 程序计数器的作用就是记录当前线程执行的位置，当线程再次被切换回来时能够知道上次执行到哪里了； 所以是为了线程切换后能恢复到正确位置上； - 两栈为什么私有呢 ？ 每个Java方法在执行的同时会创建一 个</description>
    </item>
    
    <item>
      <title>垃圾收集器和内存分配策略</title>
      <link>https://onlythepiano.github.io/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</link>
      <pubDate>Thu, 02 Jul 2020 21:34:01 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</guid>
      <description>垃圾收集器和内存分配策略 Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。 垃圾收集（Garbage Collection）需考虑的 3 件事情： 哪些内存需要回收？ 什么时候回收呢？ 如何回收？ GC 关注的内存 程序计数器、虚拟机栈、本地方法栈3个区域随线程</description>
    </item>
    
    <item>
      <title>String类和常量池</title>
      <link>https://onlythepiano.github.io/string%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/</link>
      <pubDate>Thu, 02 Jul 2020 20:29:09 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/string%E7%B1%BB%E5%92%8C%E5%B8%B8%E9%87%8F%E6%B1%A0/</guid>
      <description>String s1 = new String(&amp;ldquo;abc&amp;rdquo;); 这句话创建了几个字符串对象？ 将创建 1 或 2 个字符串。 如果池中已存在字符串常量 “abc”，则只会在堆空间创建一个字符串常量 “abc”。如果池中没有字符串常量 “abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。 原文链接：https://github.com/Sn</description>
    </item>
    
    <item>
      <title>Java内存区域与内存溢出异常</title>
      <link>https://onlythepiano.github.io/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Thu, 02 Jul 2020 19:54:04 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</guid>
      <description>Java内层区域与内存溢出异常 对于 Java 程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个 new 操作去写配对的 delete/free 代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存。这一切看起来都很美好。 不过，也正是因为 Java 程序员把内存控制的权力交给了 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟</description>
    </item>
    
    <item>
      <title>责任链模式</title>
      <link>https://onlythepiano.github.io/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 30 Jun 2020 21:12:48 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>责任链模式 一、为什么？ 职责链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链， 并沿着这条链传递该请求，直到有一个对象处理它为止。 “这里发出这个请求的客户端并不知道这当中的哪一个对象最终处理这个请求，这样系统</description>
    </item>
    
    <item>
      <title>中介者模式</title>
      <link>https://onlythepiano.github.io/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 27 Jun 2020 21:44:09 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>一、为什么？ MVC 模式，C（Controller控制器）是 M（Model模型）和 V（View视图）的中介者，在前后端交互时起到了中间人的作用。 如果大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，这对系统的行为进行任何较大的改动就十分困难了。 二、中介者模式 中介者模式 (</description>
    </item>
    
    <item>
      <title>装饰者模式</title>
      <link>https://onlythepiano.github.io/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 22 Jun 2020 21:05:14 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>一、为什么？ 搭配衣服的时候，我们往往会有多种搭配方式。我们人自己是主体，而衣服是装饰，可以有根据不同情况而有多种选择。 喝奶茶的时候，我们往往也有多种加料方式。 与建筑者模式不同的是，建筑的过程是稳定的；这里来说，如果衣服的搭配是稳定的就会，搭配方式1（大T恤、大跨库）和搭配方式2（小T恤、小垮裤）等。</description>
    </item>
    
    <item>
      <title>复制</title>
      <link>https://onlythepiano.github.io/%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 22 Jun 2020 20:51:42 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%A4%8D%E5%88%B6/</guid>
      <description>C 打扰了</description>
    </item>
    
    <item>
      <title>数理逻辑</title>
      <link>https://onlythepiano.github.io/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/</link>
      <pubDate>Mon, 22 Jun 2020 14:46:40 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/</guid>
      <description>命题逻辑 以自然语言中可判断真假的陈述句为基本单位实现数字化和符号化 - 命题： 自然语言中可判断真假的陈述句。 是否为命题在于其是否唯一真值，而这个真值与我们是否知道无关。 我正在说谎话：没有唯一真值； 好美的音乐啊：不是陈述句； 计算机专业学生必须选修高等数学：命题； -否定联结词： 美国的首都不是洛杉矶： 3 不是奇</description>
    </item>
    
    <item>
      <title>MySQL-应用层优化</title>
      <link>https://onlythepiano.github.io/mysql-%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 22 Jun 2020 14:29:25 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/mysql-%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96/</guid>
      <description>应用层优化 我们在应用中反复看到一些相同的问题，经常是因为人们使用了觖乏设计的现成系统或者简单开发的流行框架。虽然有时候可以通过这些框架更快更简单地构建系统，但是如果不清楚这些框架背后做了什么操作，反而会增加系统的风险。 - 常见问题： 什么东西再消耗每台主机的CUP、磁盘、网络和内存资源呢？ 应用真的需要获</description>
    </item>
    
    <item>
      <title>MySQL-高级特性</title>
      <link>https://onlythepiano.github.io/mysql-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 22 Jun 2020 13:39:37 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/mysql-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</guid>
      <description>MySQL 高级特性 首先，查询是如何执行的？ 客户端发送一条查询给服务器。 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计。 MySQL 根据优化器生成的执行计划，调用存储引擎的API来执行查询。 将结果返回给客户端。 查询缓存 MySQL 查</description>
    </item>
    
    <item>
      <title>MySQL-查询性能优化</title>
      <link>https://onlythepiano.github.io/mysql-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 22 Jun 2020 13:38:03 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/mysql-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>查询性能优化 重要是响应时间。 如果把查询看作是一个任务，那么它由一系列子任务组成，每个子任务都会消耗-一定的时间。如果要优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务执行时间更快。 查询的生命周期大致可以按照顺序来看:从客户端，到服务器，然后在服务器.上进</description>
    </item>
    
    <item>
      <title>Java输入输出</title>
      <link>https://onlythepiano.github.io/java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</link>
      <pubDate>Mon, 22 Jun 2020 10:58:57 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</guid>
      <description>Java 输入输出 File类 File 类是 java.io 包下代表与平台无关的文件和目录，也就是说,如果希望在程序中操作文件和目录，都可以通过File类来完成。 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。 1.访问文件和目录 - 访问文件名相关的方法： String getName(): 返回此File对象所表示的文件名或路径名( 如果是路</description>
    </item>
    
    <item>
      <title>6号杯</title>
      <link>https://onlythepiano.github.io/6%E5%8F%B7%E6%9D%AF/</link>
      <pubDate>Mon, 22 Jun 2020 08:21:50 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/6%E5%8F%B7%E6%9D%AF/</guid>
      <description>惊！ NULL 广告：作文征集 明天有素材？后天有素材？期待你们的分享😄 联系方式：QQ“绿色健康小清新” 目的 每次 git 上传博客到 github pages 时都要一一修改图片的地址，很麻烦了。 图片地址修改 利用 Java File 类对文件读取和写入和 String 类的 replaceAll() 方法替换。 输入输出都是文本内容，所以使用字符流。 BufferedReader.readLine() 方法，可以一次读入一行的内容，方便读取输入流文本内</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://onlythepiano.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Mon, 22 Jun 2020 00:16:42 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>正则表达式 正则表达式是一个强大的字符串处理工具,可以对字符串进行查找、提取、分割、替换等操作。 - String 类提供的有关正则的方法： boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。 String replaceAll(String regex, String replacement)：将该字符串中所有匹配regex的子串替换成 replacement。 String replaceFirst(String regex, String replace</description>
    </item>
    
    <item>
      <title>分表和分区</title>
      <link>https://onlythepiano.github.io/%E5%88%86%E8%A1%A8%E5%92%8C%E5%88%86%E5%8C%BA/</link>
      <pubDate>Sun, 21 Jun 2020 09:55:30 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%88%86%E8%A1%A8%E5%92%8C%E5%88%86%E5%8C%BA/</guid>
      <description>分 因为分库、分表可以将大表切分成多个片段，每次检索时可以只检索一小个片段，且因为这些片段可以分开存放在不同存储设备、不同数据库服务器上，它的整体性能得到了很大的提高。 原文链接：https://www.cnblogs.com/f-ck-need-u/p/9388407.html 业务分库 业务分库：按业务</description>
    </item>
    
    <item>
      <title>索引</title>
      <link>https://onlythepiano.github.io/%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sun, 21 Jun 2020 08:09:01 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E7%B4%A2%E5%BC%95/</guid>
      <description>背景知识 - 数据库的性能问题 磁盘IO性能非常低，严重的影响数据库系统的性能。 磁盘顺序读写比随机读写的性能高很多。 - 数据的基本存储结构 磁盘空间被划分为许多大小相同的块（Block）或者页(Page). 一个表的这些数据块以链表的方式串联在一起。 数据是以行（Row）为单位一行一行的存放在磁盘上的块中,如图所</description>
    </item>
    
    <item>
      <title>数据查询</title>
      <link>https://onlythepiano.github.io/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Sat, 20 Jun 2020 17:33:05 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2/</guid>
      <description>数据查询 学生表：Student(Sno, Sname, Ssex, Sage, Sdept) 课程表：Course(Cno, Cname, Cpno, Ccredit) 学生选课表：SC(Sno, Cno, Grade) Sdept：院系、Cpno：先修课、Ccredit：学分 单表查询 1.选择表中若干列 查询指定列：SELECT Sno, Sname FROM Student; 查询全部列：SELECT * FROM Student; 查询经过计算的值：SELECT Sname, 2014-Sage FROM Student; se</description>
    </item>
    
    <item>
      <title>MySQL-数据类型</title>
      <link>https://onlythepiano.github.io/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 20 Jun 2020 17:28:04 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>数据类型 更小的通常更好 占用更少磁盘、内存和CPU缓存 简单更好 操作时需要更少的CPU周期 避免NULL 可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理 整数类型 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。 整数计算一般</description>
    </item>
    
    <item>
      <title>B树</title>
      <link>https://onlythepiano.github.io/b%E6%A0%91/</link>
      <pubDate>Sat, 13 Jun 2020 10:26:33 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/b%E6%A0%91/</guid>
      <description>目的 二叉树，虽然查找查找速度非常快，比较次数也少；但是并不适合于存储设备，B树是为了存储设备或者磁盘而设计的一种平衡查找树。 在大数据存储过程，大量的数据会存储到外存磁盘，外存磁盘中读取与写入某数据的时候，首先定位到磁盘中的某一块；为了减少读写次数，B 树是一颗多叉树，成功降低了树得深度。 B- 树 动态查找树</description>
    </item>
    
    <item>
      <title>建筑者模式</title>
      <link>https://onlythepiano.github.io/%E5%BB%BA%E7%AD%91%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 Jun 2020 09:37:11 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%BB%BA%E7%AD%91%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>建筑者模式 一、为什么 我不理，既然都有了高的小人，那你顺便给我再加一个胖的。 你仔细分析会发现，这里建造小人的‘过程’ 是稳定的，都需要头身手脚，而具体建造的‘细节’是不同的，有胖有瘦有高有矮。但对于用户来讲，我才不管这些，我只想告诉你，我需要一个胖小人来游戏，于是你就建造一一个给我就行了。 如果你需要将一</description>
    </item>
    
    <item>
      <title>Java并发-进程线程</title>
      <link>https://onlythepiano.github.io/java%E5%B9%B6%E5%8F%91-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 08 Jun 2020 09:10:34 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/java%E5%B9%B6%E5%8F%91-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</guid>
      <description>惊！ LUCK，cherish every pay! 广告：作文征集 明天有素材？后天有素材？期待你们的分享😄 联系方式：QQ“绿色健康小清新” 目标 怎么还能混淆进程和线程的呢？ 进程和线程 引入进程：使得多个程序并发执行，改善资源利用率和提高系统效率。 进程之后引入了线程：为了减少程序并行时候所付出的时空开销，使得并发现更好。 解决</description>
    </item>
    
    <item>
      <title>外观模式</title>
      <link>https://onlythepiano.github.io/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 08 Jun 2020 08:52:22 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>外观模式 一、为什么？ 经典的三层架构，在数据访问层和业务逻辑层、业务逻辑层和表示层的层与层之间建立外观类Facade，这样可以为复杂的子系统提供一个 简单的接口，使得耦合大大降低。 还有，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也都会产生很多很小的类，这本是 好事，但也给外部调用它们</description>
    </item>
    
    <item>
      <title>单例模式2</title>
      <link>https://onlythepiano.github.io/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F2/</link>
      <pubDate>Fri, 05 Jun 2020 16:55:55 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F2/</guid>
      <description>单例模式2 为什么？ 我们在编程中最常用的模式就是单例模式了，然而单例模式都用在什么场合？ 为什么不用静态方法而要用单例模式呢？ 要搞清这些问题，需要从静态方法和非静态方法的区别和联系说起。 一、静态方法常驻内存，非静态方法只有使用的时候才分配内存吗？ 一般都认为是这样，并且怕静态方法占用过多内存而建议使用非静</description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>https://onlythepiano.github.io/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 05 Jun 2020 16:54:51 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例模式 一、为什么？ “写一个MDI窗体程序，当中有一个是‘工具箱’的窗体，问题就是，我希望工具箱要么不出现，出现也只出现一个，可实际上却是我每点击菜单，实例化‘工具箱’，它就会出来一个，这样点击多次就会出现很多个‘工具箱’，你说怎么办?” 二、责任问题 一般情况下为了方便，工具箱&amp;rsquo; FormT</description>
    </item>
    
    <item>
      <title>观察者模式</title>
      <link>https://onlythepiano.github.io/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 04 Jun 2020 13:51:50 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式 一、为什么？ 如何在老板不在时开小差又不被发现？于是就请前台的小美帮忙，如果老板出门后回来，就打个电话进来，大家也好马上各就各位，这样就不会被老板发现问题了。 ”观察者模式的关键对象是主题Subject和观察者Observer；**一个Subject可以有任意数目的依赖它Observer，一旦</description>
    </item>
    
    <item>
      <title>工厂方法模式</title>
      <link>https://onlythepiano.github.io/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 04 Jun 2020 13:04:12 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂方法模式 一、为什么？ ​ 简单工厂模式引入”工厂“类只是解决对象的创建问题，将对象的创建交给了“工厂”；对象多了，工厂也就拥挤了。于是，为了改变工厂拥挤的问题，有了工厂方法模式。 工厂方法模式和简单工厂的区别所在： 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相</description>
    </item>
    
    <item>
      <title>策略模式结合简单工厂模式</title>
      <link>https://onlythepiano.github.io/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E5%90%88%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 Jun 2020 13:33:09 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E5%90%88%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>策略模式与简单工厂模式结合 一、为什么？ “难道简单工厂就一定要是一个单独的类吗?难道不可以与策略模式的Context结合?” 于是，将客户端判断代码搬运到Context构造器中，客户端传入需要的”收费方式字符串“就可以了。 二、策略模式与简单工厂模式结合 1）Context类代码： class CashContext { CashSuper cs = null; public CashContext(string type) { switch (type)</description>
    </item>
    
    <item>
      <title>策略模式</title>
      <link>https://onlythepiano.github.io/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 Jun 2020 13:30:04 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>策略模式 一、为什么？ 商场收银时如何促销，用打折还是返利，其实都是一些算法，用工厂来生成算法对象，这没有错，但算法本身只是一种策略，最重要的是这些算法是随时都可能互相替换的，这就是变化点，而封装变化点是我们面向对象的一种 很重要的思维方式。 简单工厂模式只是解决对象的创建问题，由于“工厂”本身包括了所有的</description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>https://onlythepiano.github.io/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 Jun 2020 13:10:10 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>简单工厂模式 一、为什么？ “比如增加开根运算，运算类是很容易变化的地方，应该考虑用一个单独的类来做这个创造实例的过程——工厂“； 顾名思义：工厂就是用来造东西的，市面上的东西，购买时我们完全不知道它是如何生产的，但是我们就可以直接购买，这就是工厂方法模式 。 二、简单工厂模式 1）工厂类代码： public class OperationFactory { public static Operation creatieOperate()</description>
    </item>
    
    <item>
      <title>4号杯</title>
      <link>https://onlythepiano.github.io/4%E5%8F%B7%E6%9D%AF/</link>
      <pubDate>Thu, 02 Jan 2020 15:02:36 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/4%E5%8F%B7%E6%9D%AF/</guid>
      <description>呵！</description>
    </item>
    
    <item>
      <title>版本控制介绍</title>
      <link>https://onlythepiano.github.io/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 20 Dec 2019 22:50:42 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E4%BB%8B%E7%BB%8D/</guid>
      <description>目的 介绍版本控制前，知道以下常用的版本控制工具有git、SVN、HG、CVS和什么是版本控制？ 什么是版本控制？ 可以把一个版本控制系统（缩写VCS）理解为一个“数据库”，在需要的时候，它可以帮你完整地保存一个项目的快照。当你需要查看一个之前的快照（称之为“版本”）时，版本控制系统可以显示出当前版本与上</description>
    </item>
    
    <item>
      <title>Mavan构建工具</title>
      <link>https://onlythepiano.github.io/mavan%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Fri, 20 Dec 2019 22:43:51 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/mavan%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</guid>
      <description>目的 介绍构建工具make、Maven等之前，先介绍编程不可少的IDE，即集成开发环境；但是为什么基本上主流的IDE都是要集成构建工具呢？ IDE例子： 一般包括：编辑器+编译器+调试器（editor+compiler+debugger） 为什么会有构建工具？ 编译步骤一般包括：预处理、编译、汇编、链接；如果</description>
    </item>
    
    <item>
      <title>Keeping</title>
      <link>https://onlythepiano.github.io/keeping/</link>
      <pubDate>Mon, 16 Dec 2019 11:49:20 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/keeping/</guid>
      <description>Thanks for thinking of me,but make the way for this man. 广告：作文征集 有一说一; 联系方式：QQ“绿色健康小清新”</description>
    </item>
    
    <item>
      <title>Hosts</title>
      <link>https://onlythepiano.github.io/hosts/</link>
      <pubDate>Mon, 16 Dec 2019 00:22:21 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/hosts/</guid>
      <description>目的 #不是注释吗？为什么要加上？ Bash 不加注释#： 192.30.253.113 github.com 199.232.5.194 github.global.ssl.fastly.net 79949@Cocola MINGW64 ~/Desktop/新建文件夹 (2) (master) $ git clone https://github.com/hlk-1135/squirrel.git Cloning into &#39;squirrel&#39;... remote: Enumerating objects: 751, done. Receiving objects: 86% (647/751), 25.33 MiB | 91.00 KiB/s 空白： 79949@Cocola MINGW64 ~/Desktop/新建文件夹 (2) (master) $ git clone https://github.com/hlk-1135/squirrel.git Cloning into &#39;squirrel&#39;... remote: Enumerating objects: 751, done. Receiving objects: 47% (358/751), 2.36 MiB | 78.00 KiB/s Cmd 不加注释#： 151.101.185.194 github.global-ssl.fastly.net 192.30.253.112 github.com 79949@Cocola MINGW64 ~/Desktop/新建文件夹 (2) (master) $ git clone https://github.com/hlk-1135/squirrel.git Cloning into &#39;squirrel&#39;... remote: Enumerating objects:</description>
    </item>
    
    <item>
      <title>Gitclone加速</title>
      <link>https://onlythepiano.github.io/gitclone%E5%8A%A0%E9%80%9F/</link>
      <pubDate>Sun, 15 Dec 2019 22:16:07 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/gitclone%E5%8A%A0%E9%80%9F/</guid>
      <description>目的 git clone特别慢是因为github.global.ssl.fastly.net域名被限制了； 当我们访问域名首先要获取对应的ip，域名解析器要解析出对应的ip，然后我们才能访问到，如果域名解析器解析错了，或解析慢，当我们访问某些域名的时候就会很慢才能访问到； 只要找到这个域名对应的ip地址，然后在</description>
    </item>
    
    <item>
      <title>3号杯</title>
      <link>https://onlythepiano.github.io/3%E5%8F%B7%E6%9D%AF/</link>
      <pubDate>Sun, 15 Dec 2019 21:42:16 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/3%E5%8F%B7%E6%9D%AF/</guid>
      <description>A sense of family responsibility ​ As we grow up and our parents grow older, we have to realize that a sense of family responsibility should pay an important role in dealing with our family members. ​ One the one hand, we should notice that it was our family that gave us life, raised us up and made us who we are today. ​ One the other hand, being responsibility for our family is undoubtedly a necessary value should be shared by all of us Chinese and passed on to the next generations. 荷花骄阳不惧、出淤泥而不染： Lotus, it does not fear the strong sunshine and keeps clean in the dirty soil. 广告：作文征集 有一说一，没素材停更了 联系方式：QQ“绿色</description>
    </item>
    
    <item>
      <title>2号杯</title>
      <link>https://onlythepiano.github.io/2%E5%8F%B7%E6%9D%AF/</link>
      <pubDate>Mon, 09 Dec 2019 20:56:50 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/2%E5%8F%B7%E6%9D%AF/</guid>
      <description>惊！ 2019年12月09日，比悲伤更悲伤的故事发生了啊 1000奖金去火锅，没有我，😔 官宣，可惜不是我，😔 广告：作文征集 明天有素材？后天有素材？期待你们的分享😄 联系方式：QQ“绿色健康小清新” 目标 依赖关系和包含关系；依赖关系和关联关系时类图最常见的关系，不能区分关系就会使得一整个类图都是同一种关系，很</description>
    </item>
    
    <item>
      <title>UML关系</title>
      <link>https://onlythepiano.github.io/uml%E5%85%B3%E7%B3%BB/</link>
      <pubDate>Sun, 08 Dec 2019 22:05:28 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/uml%E5%85%B3%E7%B3%BB/</guid>
      <description>所有的 实例方法 都是 静态方法 —— 底层内核根本就没有 “实例方法” 这个概念。 所以：只要不是 架构层的东西，能用静态方法就用静态方法。 区别在于，静态方法的内存常驻；非静态的有机会释放。 用例图常用关系 包含关系与泛化关系的区分： 不复杂的理解，举个例子：制作奶茶； 所以2是1的包含；3是1的泛化；4是1的扩展； 用例1</description>
    </item>
    
    <item>
      <title>1号杯</title>
      <link>https://onlythepiano.github.io/1%E5%8F%B7%E6%9D%AF/</link>
      <pubDate>Sat, 07 Dec 2019 14:25:18 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/1%E5%8F%B7%E6%9D%AF/</guid>
      <description>惊！ 广告：作文征集 要求1：文章开头必须有引言；文中不得出现具体的人名、宿舍名等；字体颜色VIP渐变； 要求2：有过TangTou项目经验优先原则； 联系方式：QQ“绿色健康小清新” GitHub项目查找笔记 in:name example 名字中有“example” in:readme example readme中有“example” in:description example 描述中有“example” stars:&amp;gt;1000</description>
    </item>
    
    <item>
      <title>数据流图画法</title>
      <link>https://onlythepiano.github.io/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E7%94%BB%E6%B3%95/</link>
      <pubDate>Thu, 05 Dec 2019 21:52:16 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E7%94%BB%E6%B3%95/</guid>
      <description>数据流图 DFD 设计原则 父图与子图的平衡原则 子图的输入输出数据流同父图对应加工的输入输出数据流必须一致，即父图与子图的平衡； 数据守恒原则： 对一个加工来说，其全部输出数据流中的数据必须能从该加工的输入数据流中直接获得；或者说是通过该加工能产生的数据； 1.外部实体与外部实体之间不存在数据流 ​ 2.外部实体与数据</description>
    </item>
    
    <item>
      <title>解决冲突 远端部署</title>
      <link>https://onlythepiano.github.io/%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81-%E8%BF%9C%E7%AB%AF%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Thu, 05 Dec 2019 17:05:44 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81-%E8%BF%9C%E7%AB%AF%E9%83%A8%E7%BD%B2/</guid>
      <description>目标 前面《Git命令分支》介绍了本地分支合并冲突发生后可以手动解决，但是对于《冲突-部署远端》发生的冲突，又应该怎么解决呢？ 其实本地分支push到远端发生时的冲突，也是因为分支合并而产生的冲突；就是将本地分支和远端分支合并，合并那就是要手动解决 git pull git pull &amp;ndash;rebase 在使用git的过程中经常需要使用到git pul</description>
    </item>
    
    <item>
      <title>冲突-远端部署</title>
      <link>https://onlythepiano.github.io/%E5%86%B2%E7%AA%81-%E8%BF%9C%E7%AB%AF%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Thu, 05 Dec 2019 13:25:00 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/%E5%86%B2%E7%AA%81-%E8%BF%9C%E7%AB%AF%E9%83%A8%E7%BD%B2/</guid>
      <description>目标 新建一个没有的Blog.md是可以很顺利的push到远端的，因为这个文件：远端和本地没有冲突；对于部署到远端，是什么时候才会发生冲突呢？ 冲突发生的时间： 在本地分支合并时，如果master主分支发生了改变，子分支dev是不能合并到master的，会发生冲突； 那对于远端的情况是怎么样的呢？ 命令： git add</description>
    </item>
    
    <item>
      <title>Hugo post文件夹</title>
      <link>https://onlythepiano.github.io/hugo-post%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Thu, 05 Dec 2019 13:16:26 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/hugo-post%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>hugo new post/ .md MarkDown文件必须要放在hugo new 生成的post文件夹里，其他文件夹或者其他命令新建文件夹都是不行的。</description>
    </item>
    
    <item>
      <title>Git分支</title>
      <link>https://onlythepiano.github.io/git%E5%88%86%E6%94%AF/</link>
      <pubDate>Thu, 05 Dec 2019 11:34:24 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/git%E5%88%86%E6%94%AF/</guid>
      <description>github上有分支master、dev： 在本地： git checkout -b dev 新建并且切换到本地dev分支 git pull origin dev 本地分支和远端分支dev相关联 或 git branch -u origin/dev 本地分支和远端分支dev相关联 github上没有dev分支： git push origin : git push origin dev:dev #或 git push origin dev #相当于默认建立与本地同名</description>
    </item>
    
    <item>
      <title>Hugo学习</title>
      <link>https://onlythepiano.github.io/hugo%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Wed, 04 Dec 2019 13:24:21 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/hugo%E5%AD%A6%E4%B9%A0/</guid>
      <description>Part-1:Hugo Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。Hugo与hexo类似，只需要记住几个简单的命令，即可生成静态博客。 下面就开始简单介绍一下这款静态博客系统 先介绍常用参数 --bind=&amp;quot;127.0.0.1&amp;quot; 服务监听IP地址； -p, --port=1313 服务监听端口； -w, --watch[=true] 监听站点目录，发现文件变更自动编译； -D, --buildDrafts 包括被标记为dra</description>
    </item>
    
    <item>
      <title>MVC框架</title>
      <link>https://onlythepiano.github.io/mvc%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Wed, 04 Dec 2019 10:57:47 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/mvc%E6%A1%86%E6%9E%B6/</guid>
      <description>MVC 框架 Model View Controller：模型(model)－视图(view)－控制器(controller) Model（模型）： 是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。 View（视图）： 是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。 Controller</description>
    </item>
    
    <item>
      <title>Git命令远端</title>
      <link>https://onlythepiano.github.io/git%E5%91%BD%E4%BB%A4%E8%BF%9C%E7%AB%AF/</link>
      <pubDate>Tue, 03 Dec 2019 21:50:03 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/git%E5%91%BD%E4%BB%A4%E8%BF%9C%E7%AB%AF/</guid>
      <description>命令顺序：git remote -&amp;gt; git branch -&amp;gt; git push Part-1:git remote 查看关联的远程仓库信息 #查看关联的远程仓库的名称 git remote # #查看关联的远程仓库的详细信息 git remote -v 通过 git clone 下载项目到本地时，项目文件夹中的 .git 目录就是版本库目录。.git 目录中的 config 文件中有远程仓库的关联配置。 新的；git init 命令初始化一个新本地仓库，它在工作目录下生成一个名为.</description>
    </item>
    
    <item>
      <title>Git命令撤销和删除</title>
      <link>https://onlythepiano.github.io/git%E5%91%BD%E4%BB%A4%E6%92%A4%E9%94%80%E5%92%8C%E5%88%A0%E9%99%A4/</link>
      <pubDate>Tue, 03 Dec 2019 21:46:25 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/git%E5%91%BD%E4%BB%A4%E6%92%A4%E9%94%80%E5%92%8C%E5%88%A0%E9%99%A4/</guid>
      <description>https://github.com/OnlyThePiano/onlythepiano.github.io.git https://onlythepiano.github.io/ Part-1:理解工作区与暂存区的区别？ 工作区：就是你在电脑上看到的目录，比如目录下testGit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)：工作区有一个隐藏目录” .git “，这个不属于工作区，这是版本库；其中版本库里面存了</description>
    </item>
    
    <item>
      <title>Git命令分支合并</title>
      <link>https://onlythepiano.github.io/git%E5%91%BD%E4%BB%A4%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6/</link>
      <pubDate>Tue, 03 Dec 2019 21:26:09 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/git%E5%91%BD%E4%BB%A4%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6/</guid>
      <description>Part-1:git merge 目标 这是一个贯穿整个GIt的分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 一、创建与合并分支 在 版本回填退里，你已经知道，</description>
    </item>
    
    <item>
      <title>E-R图</title>
      <link>https://onlythepiano.github.io/e-r%E5%9B%BE/</link>
      <pubDate>Mon, 02 Dec 2019 21:39:36 +0800</pubDate>
      
      <guid>https://onlythepiano.github.io/e-r%E5%9B%BE/</guid>
      <description>用户： 用户可以对已完成订单发表评论； 用户可以搜索想买的商品，想要预定的酒店和交通工具等； 用户可以有多个订单，每个订单对应于一个收货地址； 商品类型包括酒店、机票、车票、旅游景点； 用户拥有添加多个地址信息作为收货地址； 用户还可以收藏自己喜欢的酒店、景点； 每个用户购买的商品还能有服务； 一个订单可以有多个商</description>
    </item>
    
  </channel>
</rss>