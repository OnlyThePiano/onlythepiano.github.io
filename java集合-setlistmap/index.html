<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1">
    <title>Java集合-Set、List、Map - Cocloa is looking at the Piano</title>

    <style type="text/css">
        img.wp-smiley,
        img.emoji {
            display: inline !important;
            border: none !important;
            box-shadow: none !important;
            height: 1em !important;
            width: 1em !important;
            margin: 0 .07em !important;
            vertical-align: -0.1em !important;
            background: none !important;
            padding: 0 !important;
        }
    </style>
    <link rel='stylesheet' href='https://onlythepiano.github.io/css/style.css' type='text/css' media='all' />
    <link rel='stylesheet' href='https://onlythepiano.github.io/css/custom.css' type='text/css' media='all' />
        
</head>
    <body class="two-column">
        <a href="#content">Skip to content</a>
<div class="wrapper">
    <header role="banner" class="banner widgets columns-1">
        <a href="/" rel="home">
            <h1 class="site">Cocloa is looking at the Piano</h1>
            <p></p>
        </a>
        <nav role="navigation" aria-label="Primary Navigation">

            <ul class="menu">
                <li class="menu-item "><a class="menu__link" href="https://onlythepiano.github.io/keeping/">KEEPING</a></li>
            </ul>
            <select onChange="location.href=value;">
                <option value="https://onlythepiano.github.io/keeping/" class="menu-item menu-item-type-custom menu-item-object-custom" >KEEPING</option>
            </select>
        </nav>
    </header>

    <br>
    <div style="width: 100%; max-height: 100px; text-align: center;">
       
</div>

    <div class="breadcrumbs">
        
    </div>
        <div id="content" class="content">

<main role="main">
    <article role="article" class="post type-post format-standard hentry">
        <header class="post-header">
            <h1>Java集合-Set、List、Map</h1>
            <div class="post-details">
                <a rel="bookmark">
                    <time datetime="2020-07-09T79:953:416">2020-07-09</time>
                </a>
				
<span style="float: right;">
    <div id="fb-root" style="height: 100%;"></div>
    
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v3.2"></script>
    
    <div class="fb-share-button" data-href="https://onlythepiano.github.io/java%E9%9B%86%E5%90%88-setlistmap/" data-layout="button_count" data-size="small">
        <a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fonlythepiano.github.io%2fjava%25E9%259B%2586%25E5%2590%2588-setlistmap%2f" class="fb-xfbml-parse-ignore">Share</a>
    </div>
    &nbsp;
    <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-text="Java集合-Set、List、Map" data-url="https://onlythepiano.github.io/java%E9%9B%86%E5%90%88-setlistmap/" data-show-count="false">Tweet</a>
    <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
    &nbsp;
    
</span>

            </div>
        </header>

        <div class="post-content">
            <h1 id="javasetlistmap">Java集合-Set、List、Map</h1>
<p><strong>- List、Set、Map 的区别：</strong></p>
<ul>
<li>List(对付顺序的好帮手)： 存储的元素是有序的、可重复的。</li>
<li>Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li>Map(用 Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上 (x,y)，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h2 id="set-">Set 集合</h2>
<ul>
<li><strong>HashSet：</strong>（无序，唯一）基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li><strong>LinkedHashSet：</strong> 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的</li>
<li><strong>TreeSet：</strong>（有序，唯一）红黑树(自平衡的排序二叉树)</li>
</ul>
<h2 id="list-">List 集合</h2>
<ul>
<li><strong>Arraylist：</strong> Object[] 数组</li>
<li><strong>Vector：</strong> Object[] 数组</li>
<li><strong>LinkedList：</strong> 双向链表 (JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h3 id="1list-">1.List 集合里增加的方法</h3>
<ul>
<li>void add(int index, Object element)： 将元素element插入到List集合的index处。</li>
<li>void sort(Comparator c)： 根据参数对集合元素排序</li>
<li>void replaceAll()： 替换</li>
<li>Object get(int index)： 返回集合index索引处的元素</li>
<li>Object remove(int index)： 删除并返回index索引处的元素</li>
<li>Object set(int index, Object element)： 将index索引处的元素替换成element对象</li>
<li>boolean addAll(int index, Collection c)： 将集合c所包含的所有元素都插入到List集合的index处</li>
<li>int indexOf(Object o)： 返回对象o在List 集合中第一次出现的位置索引</li>
<li>List subList(int fromIndex, int toIndex)： 返回从索引 [formIndex, toIndex) 的元素组成的子集合</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span>
<span style="color:#f92672">{</span>
    List books <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">(</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    books<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    books<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    books<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;c&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    books<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;d&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
    
    books<span style="color:#f92672">.</span><span style="color:#a6e22e">indexOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;d&#34;</span><span style="color:#f92672">)</span><span style="color:#f92672">)</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
运行结果:
能够返回 1 <span style="color:#f92672">,</span> 表明 d 位于第二位
</code></pre></div><p><strong>注意：</strong> 1 处的元素 d 时通过 new 关键字创建，所以两个字符串就i不是用一个对象，而 List 却将两个对象判断为相等是为什么？</p>
<p>List 判断两个对象相等是通过 <code>equals()</code> 方法；List 重写了该方法，使得只要内容相同即可判断对象是相同的。</p>
<h3 id="2arraylist--vector-">2.ArrayList 和 Vector 比较</h3>
<ol>
<li>ArrayList 是 List 的主要实现类，底层使用 Object<input disabled="" type="checkbox">存储，适用于频繁的查找工作，线程不安全 ；</li>
<li>Vector 是 List 的古老实现类，底层使用 Object<input disabled="" type="checkbox">存储，线程安全的。</li>
</ol>
<h3 id="3">3.各种线性表的选择</h3>
<ul>
<li>遍历 List 集合元素，对于 ArrayList、Vector 集合，采用随机访问（get）；对于 LinkedList 集合，采用迭代器（Iterator）；</li>
<li>需要经常插入、删除操作时，采用 LinkedList 集合；</li>
<li>多线程时，采用 Collections 工具类包装；</li>
</ul>
<h2 id="map-">Map 集合</h2>
<ul>
<li><strong>HashMap：</strong> JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li>
</ul>
<p><strong>注意：</strong> 为了成功地在 HashMap、Hashtable 中存储、获取对象，用作 key 的对象也必须实现 <code>hashCode()</code> 方法和 <code>equals()</code> 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
<span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">A</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> count<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> count<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#f92672">(</span>1<span style="color:#f92672">)</span>根据count判断两个对象是否相等
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object obj<span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>obj <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">)</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>obj <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> obj<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> A<span style="color:#f92672">.</span><span style="color:#a6e22e">class</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            A a <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>A<span style="color:#f92672">)</span>obj<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span><span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">count</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    
    <span style="color:#f92672">(</span>2<span style="color:#f92672">)</span>计算hasCode的值
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hasCode</span><span style="color:#f92672">(</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">count</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，就会会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用<code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。</p>
<h3 id="1map-">1.Map 集合里增加的方法</h3>
<ul>
<li>void clear()： 删除 Map 对象中的所有 key-value 对</li>
<li>Object get(Object key)：返回指定 Key 所对应的 value</li>
<li>Object put(Object key, Object value)：添加</li>
<li>Object remove(Object key)：删除指定 Key 所对应的 Key-value 对</li>
<li>boolean remove(Object key, Object value)：删除指定 Key-value</li>
<li>boolean containsKey(Object key)：查询是否包含指定 Key</li>
</ul>
<h3 id="2hashmap--hashtable-">2.HashMap 和 Hashtable 的比较</h3>
<ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h3 id="3hashmap--hashsethashtree-">3.HashMap 和 HashSet、HashTree 比较</h3>
<p>看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<p>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p>
<h2 id="collections-">Collections 工具类</h2>
<p><strong>- Collections 工具类常用方法:</strong></p>
<ol>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制 (不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ol>
<h3 id="1-">1. 排序操作</h3>
<pre><code>void reverse(List list)//反转
void shuffle(List list)//随机排序
void sort(List list)//按自然排序的升序排序
void sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑
void swap(List list, int i , int j)//交换两个索引位置的元素
void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面
</code></pre><h3 id="2-">2. 查找,替换操作</h3>
<pre><code>int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)
int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)
void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。
int frequency(Collection c, Object o)//统计元素出现次数
int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).
boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素
</code></pre><h3 id="3-">3. 同步控制</h3>
<p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList`,</code>LinkedList<code>,</code>HashMap<code>,</code>TreeMap<code> 都是线程不安全的。</code>Collections` 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>
<p>方法如下：</p>
<pre><code>synchronizedCollection(Collection&lt;T&gt;  c) //返回指定 collection 支持的同步（线程安全的）collection。
synchronizedList(List&lt;T&gt; list)//返回指定列表支持的同步（线程安全的）List。
synchronizedMap(Map&lt;K,V&gt; m) //返回由指定映射支持的同步（线程安全的）Map。
synchronizedSet(Set&lt;T&gt; s) //返回指定 set 支持的同步（线程安全的）set。
</code></pre><h2 id="heading">如何选用集合?</h2>
<p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>

        </div>



        <footer class="post-footer">
                
                
                
                <span class="post-categories">
                        <a href="https://onlythepiano.github.io/categories/java/">Java</a>&emsp;
                        
                </span>
                
        
                
                
                
        </footer>
        
<table cellspacing="15" style="width:100%; border: none;">
    <tr>
        <td style="text-align: center; border: none; padding: 0px;">
        </td>
        <td style="text-align: center; border: none; padding: 0px;">
        </td>
    </tr>
</table>

        
	
	

    </article>

    
    <nav class="navigation post-navigation" role="navigation">
        <div class="nav-links">
            <div class="nav-previous">
                
                <a class="previous" href="https://onlythepiano.github.io/java%E9%9B%86%E5%90%88/"> Java集合</a>
                
            </div>
            <div class="nav-next">
                
                <a class="next" href="https://onlythepiano.github.io/%E5%BA%8F%E5%88%97%E5%8C%96/"> 序列化</a>
                
            </div>
        </div>
    </nav>
    <section>
        
    </section>
    

</main>


        <div class="sidebar1 widgets columns-1">

    <aside>
    
</aside>
    <aside class="widget widget_categories">
        <h2>Categories</h2>
        <ul class="widget__list"><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/git/">Git (9)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/hugo/">Hugo (2)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/java/">Java (19)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/mysql/">MySQL (9)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/uml/">UML (2)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/%E5%8F%AF%E4%B9%90/">可乐 (7)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构 (2)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">离散数学 (1)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/%E7%AE%97%E6%B3%95/">算法 (1)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式 (13)</a>
            </li><li class="cat-item cat-item-2">
                <a href="https://onlythepiano.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程 (2)</a>
            </li>
        </ul>
    </aside>

    <aside class="widget widget_tag_cloud">
        <h2>Tags</h2>
        <div class="tagcloud"><a class="tag-cloud-link" href="https://onlythepiano.github.io/tags/out-of-mess/" title="out-of-mess" style="font-size: 12pt;">out of mess</a>&emsp;<a class="tag-cloud-link" href="https://onlythepiano.github.io/tags/out-of-messy/" title="out-of-messy" style="font-size: 12pt;">out of messy</a>&emsp;
        </div>
    </aside>

    <aside class="widget widget_recent_entries">
        <h2>Recent Posts</h2>
        <ul>
            <li>
                <a href="/%E5%8F%8D%E5%B0%84/">反射</a>
            </li>
            <li>
                <a href="/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93-class%E7%B1%BB/">Java基础类库-Class类</a>
            </li>
            <li>
                <a href="/%E5%BA%8F%E5%88%97%E5%8C%96/">序列化</a>
            </li>
            <li>
                <a href="/java%E9%9B%86%E5%90%88-setlistmap/">Java集合-Set、List、Map</a>
            </li>
            <li>
                <a href="/java%E9%9B%86%E5%90%88/">Java集合</a>
            </li>
            <li>
                <a href="/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93-string%E7%B1%BB/">Java基础类库-String类</a>
            </li>
            <li>
                <a href="/java%E5%AD%90%E7%B1%BB%E7%88%B6%E7%B1%BB%E8%BD%AC%E6%8D%A2/">Java子类父类转换</a>
            </li>
            <li>
                <a href="/java%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%BA%93-object%E7%B1%BB/">Java基础类库-Object类</a>
            </li>
            <li>
                <a href="/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/">时间复杂度</a>
            </li>
            <li>
                <a href="/%E6%B3%9B%E5%9E%8B/">泛型</a>
            </li>
        </ul>
    </aside>

    <aside class="widget widget_archive">
        <h2>Archives</h2>
        <ul>
        </ul>
    </aside>

</div>
        </div>
        </div>
<footer role="contentinfo" class="document-footer contentinfo widgets columns-1">

    <aside class="widget widget_text">
        <div class="textwidget">
            <p>© Cocloa is looking at the Piano / Powered by <a href="https://gohugo.io" target="_blank">Hugo</a> with theme <a href="https://github.com/tosi29/inkblotty" target="_blank">Inkblotty</a></p>
        </div>
    </aside>
</footer>
</div>

    </body>
</html>
